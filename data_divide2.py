#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
data_divide2.py
~~~~~~~~~~~~~~~~~~~~~
This script uses the 3d slices generated by unet to get left&right lungs precisely, 
without mach black background (you can write you own version!).

:author: Lei Hu
:email: hul22@mails.tsinghua.edu.cn
:copyright: (c) 2025 by Lei Hu.
:license: MIT License, see LICENSE for more details.
"""

__version__ = "0.1.0"

import imageio
import numpy as np

def crop_nonzero_boundary(arr):
    # 获取数组中所有非零元素的行和列索引
    nonzero_rows = np.any(arr != 0, axis=1)  # 每一行是否有非零元素
    nonzero_cols = np.any(arr != 0, axis=0)  # 每一列是否有非零元素

    # 找到最上面、最下面、最左边、最右边的非零边界
    top = np.argmax(nonzero_rows)  # 最上面非零行
    bottom = arr.shape[0] - np.argmax(nonzero_rows[::-1]) - 1  # 最下面非零行
    left = np.argmax(nonzero_cols)  # 最左边非零列
    right = arr.shape[1] - np.argmax(nonzero_cols[::-1]) - 1  # 最右边非零列

    # 截取包含非零元素的子数组
    cropped_arr = arr[top:bottom+1, left:right+1]
    
    return cropped_arr

# 打开TIFF文件
folder_path = 'data_unprocessed/data_unprocessed/241215_403/t.tif'
img = np.array(imageio.mimread(folder_path))

left = img[:, :img.shape[1] // 2, :]  # 左半部分
right = img[:, img.shape[1] // 2:, :]  # 右半部分

# breakpoint()
for i in range(img.shape[0]):
    left_path = f'data_unprocessed/data_unprocessed/data/left/left_part{i}.tif'
    right_path = f'data_unprocessed/data_unprocessed/data/right/right_part{i}.tif'

    # 保存左右部分为新的 TIFF 文件
    left_i = left[i,:,:]
    right_i = right[i,:,:]
    imageio.imwrite(left_path, crop_nonzero_boundary(left_i))
    imageio.imwrite(right_path, crop_nonzero_boundary(right_i))
